'use strict';var recurseDelete = function () {var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(
























































































  function _callee3(archive, targetPath, st) {var children, i;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:if (


            st) {_context3.next = 4;break;}_context3.next = 3;return (
              stat(archive, targetPath));case 3:st = _context3.sent;case 4:if (!

            st.isFile()) {_context3.next = 8;break;}return _context3.abrupt('return',

            new Promise(function (resolve, reject) {
              archive.unlink(targetPath, function (err) {
                if (err) reject(toBeakerError(err, 'unlink'));else
                resolve();
              });
            }));case 8:if (!
            st.isDirectory()) {_context3.next = 22;break;}_context3.next = 11;return (

              readdir(archive, targetPath));case 11:children = _context3.sent;

            i = 0;case 13:if (!(i < children.length)) {_context3.next = 19;break;}_context3.next = 16;return (
              recurseDelete(archive, path.join(targetPath, children[i])));case 16:i++;_context3.next = 13;break;case 19:return _context3.abrupt('return',


            new Promise(function (resolve, reject) {
              archive.rmdir(targetPath, function (err) {
                // FIXME
                // there's a hyperdrive bug that causes empty dirs to register as NotFound
                // https://github.com/mafintosh/append-tree/issues/6
                // if (err) reject(toBeakerError(err, 'rmdir'))
                // else resolve()
                if (err) {
                  console.warn('rmdir issue (append-tree#6)', err);
                }
                resolve();
              });
            }));case 22:throw (

              new Error('Unexpectedly encountered an entry which is neither a file or directory at', path));case 23:case 'end':return _context3.stop();}}}, _callee3, this);}));return function recurseDelete(_x, _x2, _x3) {return _ref3.apply(this, arguments);};}();function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var path = require('path');var _require = require('./common'),maybe = _require.maybe,toBeakerError = _require.toBeakerError;var _require2 = require('beaker-error-constants'),NotFoundError = _require2.NotFoundError,NotAFileError = _require2.NotAFileError,NotAFolderError = _require2.NotAFolderError,DestDirectoryNotEmpty = _require2.DestDirectoryNotEmpty,ArchiveNotWritableError = _require2.ArchiveNotWritableError;var _require3 = require('./lookup'),stat = _require3.stat;var _require4 = require('./read'),readdir = _require4.readdir;function unlink(archive, name, cb) {return maybe(cb, _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var st;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:if (!(archive.key && !archive.writable)) {_context.next = 2;break;}throw new ArchiveNotWritableError();case 2:_context.prev = 2;_context.next = 5;return stat(archive, name);case 5:st = _context.sent;_context.next = 10;break;case 8:_context.prev = 8;_context.t0 = _context['catch'](2);case 10:if (st) {_context.next = 12;break;}throw new NotFoundError();case 12:if (st.isFile()) {_context.next = 14;break;}throw new NotAFileError('Cannot unlink non-files');case 14:return _context.abrupt('return', new Promise(function (resolve, reject) {archive.unlink(name, function (err) {if (err) reject(toBeakerError(err, 'unlink'));else resolve();});}));case 15:case 'end':return _context.stop();}}}, _callee, this, [[2, 8]]);})));}function rmdir(archive, name, opts, cb) {if (typeof opts === 'function') {cb = opts;opts = {};}return maybe(cb, _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var recursive, st, children;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:opts = opts || {};recursive = opts && opts.recursive; // ensure we have the archive's private key
            if (!(archive.key && !archive.writable)) {_context2.next = 4;break;}throw new ArchiveNotWritableError();case 4:_context2.prev = 4;_context2.next = 7;return stat(archive, name);case 7:st = _context2.sent;_context2.next = 12;break;case 10:_context2.prev = 10;_context2.t0 = _context2['catch'](4);case 12:if (st) {_context2.next = 14;break;}throw new NotFoundError();case 14:if (st.isDirectory()) {_context2.next = 16;break;}throw new NotAFolderError('Cannot rmdir non-folders');case 16:if (!recursive) {_context2.next = 23;break;}_context2.prev = 17;return _context2.abrupt('return', recurseDelete(archive, name, st));case 19:_context2.prev = 19;return _context2.finish(19);case 21:_context2.next = 29;break;case 23:_context2.next = 25;return readdir(archive, name);case 25:children = _context2.sent;if (!children.length) {_context2.next = 28;break;}throw new DestDirectoryNotEmpty();case 28:return _context2.abrupt('return', new Promise(function (resolve, reject) {archive.rmdir(name, function (err) {if (err) reject(toBeakerError(err, 'rmdir'));else resolve();});}));case 29:case 'end':return _context2.stop();}}}, _callee2, this, [[4, 10], [17,, 19, 21]]);})));}


module.exports = { unlink, rmdir };