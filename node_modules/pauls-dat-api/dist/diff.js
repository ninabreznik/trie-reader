'use strict';function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var dft = require('diff-file-tree');
var path = require('path');var _require =
require('./common'),maybe = _require.maybe,tonix = _require.tonix;

function diff(leftArchive, leftPath, rightArchive, rightPath, opts, cb) {
  if (typeof opts === 'function') cb = opts;
  if (typeof opts !== 'object') opts = undefined;
  opts = massageDiffOpts(opts || {});

  return maybe(cb, _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var changes;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (

              dft.diff(
              { fs: leftArchive, path: leftPath },
              { fs: rightArchive, path: rightPath },
              opts));case 2:changes = _context.sent;


            // apply ops filter
            if (opts.ops && opts.ops.length) {
              changes = changes.filter(function (change) {return opts.ops.includes(change.change);});
            }return _context.abrupt('return',

            changes);case 5:case 'end':return _context.stop();}}}, _callee, this);})));

}

function merge(leftArchive, leftPath, rightArchive, rightPath, opts, cb) {
  if (typeof opts === 'function') cb = opts;
  if (typeof opts !== 'object') opts = undefined;
  opts = massageDiffOpts(opts || {});

  // override the shallow option, it can never be true for merges
  opts.shallow = false;

  return maybe(cb, _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var changes;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (

              diff(leftArchive, leftPath, rightArchive, rightPath, opts));case 2:changes = _context2.sent;_context2.next = 5;return (


              dft.applyRight(
              { fs: leftArchive, path: leftPath },
              { fs: rightArchive, path: rightPath },
              changes));case 5:return _context2.abrupt('return',


            changes);case 6:case 'end':return _context2.stop();}}}, _callee2, this);})));

}

function makeDiffFilterByPaths(targetPaths) {
  targetPaths = targetPaths.filter(function (v) {return typeof v === 'string';}).map(path.normalize).map(tonix);
  return function (filepath) {
    filepath = tonix(filepath);
    if (filepath === '/dat.json') return true; // never diff/merge dat.json
    if (targetPaths.length === 0) return false;

    for (var i = 0; i < targetPaths.length; i++) {
      var targetPath = targetPaths[i];

      if (filepath === targetPath) return false; // exact match
      if (filepath.startsWith(targetPath) && filepath.charAt(targetPath.length) === '/') {
        return false; // a parent folder
      }

    }
    return true;
  };
}

function massageDiffOpts(opts) {
  return {
    compareContent: typeof opts.compareContent === 'boolean' ? opts.compareContent : false,
    shallow: typeof opts.shallow === 'boolean' ? opts.shallow : false,
    filter: opts.filter || makeDiffFilterByPaths(Array.isArray(opts.paths) ? opts.paths : []),
    ops: (Array.isArray(opts.ops) ? opts.ops : [opts.ops]).filter(function (v) {return typeof v === 'string';}) };

}

module.exports = { diff, merge };