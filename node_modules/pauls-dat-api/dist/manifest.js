'use strict';function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var _require = require('./const'),DAT_MANIFEST_FILENAME = _require.DAT_MANIFEST_FILENAME,DAT_HASH_REGEX = _require.DAT_HASH_REGEX;var _require2 =
require('./common'),maybe = _require2.maybe;var _require3 =
require('./read'),readFile = _require3.readFile;var _require4 =
require('./write'),writeFile = _require4.writeFile;

// helper to read the manifest into an object
function readManifest(archive, cb) {
  return maybe(cb, _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var data;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
              readFile(archive, DAT_MANIFEST_FILENAME));case 2:data = _context.sent;
            data = JSON.parse(data.toString());
            if (data.links) data.links = massageLinks(data.links);return _context.abrupt('return',
            data);case 6:case 'end':return _context.stop();}}}, _callee, this);})));

}

// helper to write a manifest object
function writeManifest(archive, manifest, cb) {
  manifest = generateManifest(manifest);
  return writeFile(archive, DAT_MANIFEST_FILENAME, JSON.stringify(manifest, null, 2), cb);
}

// helper to write updates to a manifest object
function updateManifest(archive, updates, cb) {
  return maybe(cb, _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {var manifest;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.prev = 0;_context2.next = 3;return (


              readManifest(archive));case 3:manifest = _context2.sent;_context2.next = 9;break;case 6:_context2.prev = 6;_context2.t0 = _context2['catch'](0);

            manifest = {};case 9:

            Object.assign(manifest, generateManifest(updates));return _context2.abrupt('return',
            writeManifest(archive, manifest));case 11:case 'end':return _context2.stop();}}}, _callee2, this, [[0, 6]]);})));

}

// helper to generate a new dat.json object
function generateManifest() {var manifest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};var
  url = manifest.url,title = manifest.title,description = manifest.description,type = manifest.type,author = manifest.author,links = manifest.links,web_root = manifest.web_root,fallback_page = manifest.fallback_page;
  if (isString(url)) manifest.url = url;else
  delete manifest.url;
  if (isString(title)) manifest.title = title;else
  delete manifest.title;
  if (isString(description)) manifest.description = description;else
  delete manifest.description;
  if (isString(type)) type = type.split(' ');
  if (isArrayOfStrings(type)) manifest.type = type;else
  delete manifest.type;
  if (isObject(links)) manifest.links = massageLinks(links);else
  delete manifest.links;
  if (isString(web_root)) manifest.web_root = web_root;else
  delete manifest.web_root;
  if (isString(fallback_page)) manifest.fallback_page = fallback_page;else
  delete manifest.fallback_page;
  if (isString(author)) {
    if (author.startsWith('dat://') || DAT_HASH_REGEX.test(author)) {
      author = { url: author };
    } else {
      author = { name: author };
    }
  }
  if (isObject(author)) {
    manifest.author = {};
    if (isString(author.name)) manifest.author.name = author.name;
    if (isString(author.url) && (author.url.startsWith('dat://') || DAT_HASH_REGEX.test(author.url))) {
      manifest.author.url = author.url;
    }
  } else {
    delete manifest.author;
  }
  return manifest;
}

function massageLinks(links) {
  if (!links || typeof links !== 'object') return {};
  for (var rel in links) {
    // make each value an array
    links[rel] = Array.isArray(links[rel]) ? links[rel] : [links[rel]];
    // link-objects only
    links[rel] = links[rel].
    map(function (link) {
      if (isString(link)) {
        return { href: link };
      }
      return link;
    }).
    filter(isLinkObject);
    // remove empty arrays
    if (links[rel].length === 0) {
      delete links[rel];
    }
  }
  return links;
}

function isString(v) {
  return typeof v === 'string';
}

function isArrayOfStrings(v) {
  return Array.isArray(v) && v.every(isString);
}

function isLinkObject(v) {
  return isObject(v) && v.href && typeof v.href === 'string';
}

function isObject(v) {
  return !!v && typeof v === 'object' && !Array.isArray(v);
}

module.exports = { readManifest, generateManifest, writeManifest, updateManifest };