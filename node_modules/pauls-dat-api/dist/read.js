'use strict';function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var path = require('path');var _require =
require('beaker-error-constants'),NotAFileError = _require.NotAFileError;var _require2 =
require('./common'),maybe = _require2.maybe,toBeakerError = _require2.toBeakerError,toValidEncoding = _require2.toValidEncoding;var _require3 =
require('./lookup'),stat = _require3.stat;

// helper to pull file data from an archive
function readFile(archive, name, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }

  return maybe(cb, _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var st;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
            opts = opts || {};
            if (typeof opts === 'string') {
              opts = { encoding: opts };
            }
            opts.encoding = toValidEncoding(opts.encoding);

            // check that it's a file
            _context.next = 5;return stat(archive, name);case 5:st = _context.sent;if (
            st.isFile()) {_context.next = 8;break;}throw (
              new NotAFileError());case 8:return _context.abrupt('return',



            new Promise(function (resolve, reject) {
              archive.readFile(name, opts, function (err, data) {
                if (err) reject(toBeakerError(err, 'readFile'));else
                resolve(data);
              });
            }));case 9:case 'end':return _context.stop();}}}, _callee, this);})));

}

// helper to list the files in a directory
function readdir(archive, name, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }
  opts = opts || {};

  return maybe(cb, _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {var recursive, promise, results, rootPath, readdirSafe, recurse;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
            // options
            recursive = opts && !!opts.recursive;

            // run first readdir
            promise = new Promise(function (resolve, reject) {
              archive.readdir(name, function (err, names) {
                if (err) reject(toBeakerError(err, 'readdir'));else
                resolve(names);
              });
            });_context4.next = 4;return (
              promise);case 4:results = _context4.sent;if (!


            recursive) {_context4.next = 11;break;}
            rootPath = name;
            readdirSafe = function readdirSafe(name) {return new Promise(function (resolve) {
                archive.readdir(name, function (_, names) {return resolve(names || []);});
              });};
            recurse = function () {var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(names, parentPath) {return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_context3.next = 2;return (
                          Promise.all(names.map(function () {var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(name) {var thisPath, subnames;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                                      thisPath = path.join(parentPath, name);_context2.next = 3;return (
                                        readdirSafe(thisPath));case 3:subnames = _context2.sent;_context2.next = 6;return (
                                        recurse(subnames, thisPath));case 6:
                                      results = results.concat(subnames.map(function (subname) {return normalize(rootPath, thisPath, subname);}));case 7:case 'end':return _context2.stop();}}}, _callee2, this);}));return function (_x3) {return _ref4.apply(this, arguments);};}())));case 2:case 'end':return _context3.stop();}}}, _callee3, this);}));return function recurse(_x, _x2) {return _ref3.apply(this, arguments);};}();_context4.next = 11;return (


              recurse(results, name));case 11:return _context4.abrupt('return',

            results);case 12:case 'end':return _context4.stop();}}}, _callee4, this);})));

}

function readSize(archive, name, cb) {
  return maybe(cb, _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {var st, children, size, i;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:_context5.next = 2;return (

              stat(archive, name));case 2:st = _context5.sent;if (!


            st.isFile()) {_context5.next = 5;break;}return _context5.abrupt('return',
            st.size);case 5:_context5.next = 7;return (



              readdir(archive, name));case 7:children = _context5.sent;

            // recurse
            size = 0;
            i = 0;case 10:if (!(i < children.length)) {_context5.next = 17;break;}_context5.next = 13;return (
              readSize(archive, path.join(name, children[i])));case 13:size += _context5.sent;case 14:i++;_context5.next = 10;break;case 17:return _context5.abrupt('return',

            size);case 18:case 'end':return _context5.stop();}}}, _callee5, this);})));

}

function normalize(rootPath, parentPath, subname) {
  var str = path.join(parentPath, subname).slice(rootPath.length);
  if (str.charAt(0) === '/') return str.slice(1);
  return str;
}

module.exports = { readFile, readdir, readSize };